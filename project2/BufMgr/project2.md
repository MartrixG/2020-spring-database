1. 介绍
    BadgerDB项目的目标是为您提供有关RDBMS关键组件的实践教育。在此项目中，您需要在提供的存储管理器之上实现缓冲区管理器
   1. BadgerDB I / O层
   BadgerDB数据库系统的最底层是I / O层。该层允许系统的上层创建/销毁文件，分配/取消分配文件中的页面以及读取/写入文件的页面。该层由两个类组成：文件（类File）和页面（类Page）。这些类使用C ++异常来处理任何意外事件的发生。向您提供了File类，Page类和异常类的实现。要启动此项目，您可以将压缩文件 夹BufMgr.zip下载到您的私有工作区，并使用以下命令解压缩该文件夹：unzip BufMgr.zip
    对该代码进行了充分的注释，以帮助您了解其功能和作用。请使用Doxygen如下所示为您的代码生成文档。在bufmgr目录中，运行以下命令以生成文档文件。
    请注意，>是Linux机器上的shell提示，不是命令的一部分。文档文件将在docs目录中生成。现在，您可以在浏览器中打开docs / index.html文件，并通过对类及其方法的描述来更好地理解其实现。
   2. BadgerDB缓冲区管理器
   数据库缓冲池是一组固定大小的内存缓冲区（称为帧），用于保存已从磁盘读取到内存中的数据库页面（也称为磁盘块）。页是磁盘和驻留在主内存中的缓冲池之间的传输单位。大多数现代DBMS使用的页面大小至少为8,192字节。另一个需要注意的重要事项是，内存中的数据库页面是磁盘上首次读取时对应页面的精确副本。一旦从磁盘将页面读取到缓冲池后，DBMS软件就可以更新存储在磁盘上的信息。页面，导致缓冲池中的副本与磁盘上的副本变得不同。这些页面被称为“脏”。
   由于磁盘上的数据库本身通常大于缓冲池可用的主内存量，因此在任何给定时间，只有一部分数据库页面可以容纳在内存中。缓冲区管理器用于控制哪些页面驻留在内存中。每当缓冲区管理器收到对数据页的请求时，缓冲区管理器都会检查以查看所请求的页是否已在构成缓冲池的帧之一中。如果是这样，则缓冲区管理器仅返回指向该页面的指针。如果不是，则缓冲区管理器释放一个帧（如果页面脏了，可以通过将其包含的页面写入磁盘），然后从磁盘中将请求的页面读入已释放的帧中。
   在进一步阅读之前，您应该首先阅读描述BadgerDB I / O层的文档，以便您了解其功能（在上一节中进行了介绍）。简而言之，I / O层为Unix文件提供了一个面向对象的接口，其中包含用于打开/关闭文件以及读取/写入文件页面的方法。现在，您需要知道的关键是打开文件（通过输入字符串名称）会返回File类型的对象。此类具有读取和写入File页面的方法。您将使用这些方法在磁盘和缓冲池之间移动页面。
   3. 缓冲区替换策略和时钟算法
   有许多方法可以确定需要空框架时要替换的页面。操作系统中常用的策略是FIFO，MRU和LRU。尽管LRU是最常用的策略之一，但是它具有高开销，并且不是在数据库系统中发生的许多常见情况下使用的最佳策略。相反，许多系统使用近似LRU行为的时钟算法，并且速度更快。
    图1显示了缓冲池的概念布局。在图1中，每个方框对应于缓冲池中的一个帧。假定缓冲池包含numBufs帧，编号为0到numBufs-1。从概念上讲，缓冲池中的所有帧都排列在循环列表中。与每个帧相关的位称为refbit。每次访问缓冲池中的页面（通过对缓冲区管理器的readPage（）调用）时，相应帧的refbit都设置为true。在任何时间点，时钟指针（其值在0到numBufs − 1之间的整数）都会以顺时针方向前进（使用模块化算术，以使其不会超过numBufs − 1）。对于时针经过的每一帧，都会检查refbit，然后将其清除。如果设置了该位，则相应的帧已被“最近”引用，并且不会被替换。另一方面，如果refbit为false，则选择要替换的页面（假设它没有固定-固定页面将在下面讨论）。如果选定的缓冲区帧是脏的（即已被修改），则当前占用该帧的页面将写回到磁盘。否则，将仅清除框架，并从该位置读取磁盘中的新页面。图2说明了时钟算法的执行。时钟算法的详细信息如下。
    4. 缓冲区管理器的结构
    BadgerDB缓冲区管理器使用三个C ++类：BufMgr，BufDesc和BufHashTbl。 BufMgr类只有一个实例。 此类的关键组成部分是实际的缓冲池，该缓冲池由numBufs帧数组组成，每个帧大小与数据库页面大小相同。 除了此数组之外，BufMgr实例还包含BufDesc类的numBufs实例的数组，该数组用于描述缓冲池中每个帧的状态。 哈希表用于跟踪缓冲池中当前驻留的页面。 该哈希表由BufHashTbl类的实例实现。 该实例是BufMgr类的私有数据成员。 这些类将在下面详细描述。